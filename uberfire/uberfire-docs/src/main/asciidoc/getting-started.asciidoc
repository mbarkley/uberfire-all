= Getting Started With UberFire
Jonathan Fuerth <jfuerth@redhat.com>

This guide will walk you through the process of setting up a new
UberFire application. Starting from an empty directory, you will
create a Maven `pom.xml` file to describe your project and its
dependencies, build up a simple application with client-side and
server-side behaviour, and learn how everything works along the way.

If you've never seen a full-blown working UberFire app before, why not
check out our Jump Start Guide first, which helps you get UberFire's
pre-made showcase application up and running on your system? This
guide will be here waiting for you when you're ready to come back and
build something yourself.

Otherwise, you're already familiar with UberFire's capabilities. So
let's get started!

== Prerequisites

This guide assumes you have the following software set up and working
on your computer:

* http://www.oracle.com/technetwork/java/javase/downloads/index.html[A
  Java Development Kit (JDK) version 6 or newer]
* http://maven.apache.org/download.cgi[Maven 3.x]
* http://www.eclipse.org/downloads/packages/eclipse-ide-java-ee-developers/keplersr1[Eclipse IDE for Java EE Developers]
  Kepler SR1 or newer, or whatever Java IDE you like better (NetBeans,
  IntelliJ IDEA)

== Create the Maven POM

The first thing you'll need is a Maven `pom.xml` file that describes
all the dependencies and special build steps of your project. Start
with this:

---------
<?xml version="1.0" encoding="UTF-8"?>
<project
  xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
  http://maven.apache.org/xsd/maven-4.0.0.xsd">

  <modelVersion>4.0.0</modelVersion>

  <name>UberFire Tutorial</name>
  <groupId>com.mycompany.sandbox</groupId>
  <artifactId>uberfire-tutorial-workbench</artifactId>
  <version>1.0.0-SNAPSHOT</version>
  <packaging>war</packaging>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.war.plugin.version>2.1.1</maven.war.plugin.version>
    <maven.clean.plugin.version>2.4.1</maven.clean.plugin.version>
    <maven.deploy.plugin.version>2.7</maven.deploy.plugin.version>
    <maven.resources.plugin.version>2.6</maven.resources.plugin.version>
    <maven.gwt.plugin.version>2.5.1</maven.gwt.plugin.version>
    <jboss-as-maven-plugin.version>7.4.Final</jboss-as-maven-plugin.version>
    <uberfire.version>0.4.0-SNAPSHOT</uberfire.version>
    <errai.version>2.4.3-SNAPSHOT</errai.version>
  </properties>

</project>
---------

Now, underneath the properties section, we'll import four Maven __BOM__
files. BOM (short for Bill Of Materials) is a Maven pattern where
frameworks publish a comprehensive set of dependency versions that
are known to work well with the framework. We'll import BOMs for
UberFire, Errai, and the Java EE 6 APIs.

Note that importing a BOM doesn't add any actual dependencies to your
project; it simply manages the versions of the direct and transitive
dependencies you do add in the `<dependencies>` section further down.

This section can be placed right below the properties section from the
previous snippet:

---------
  <dependencyManagement>
    <dependencies>

      <dependency>
        <groupId>org.jboss.errai.bom</groupId>
        <artifactId>errai-version-master</artifactId>
        <version>${errai.version}</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>

      <dependency>
        <groupId>org.jboss.errai</groupId>
        <artifactId>errai-parent</artifactId>
        <version>${errai.version}</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>

      <dependency>
        <groupId>org.uberfire</groupId>
        <artifactId>uberfire</artifactId>
        <version>${uberfire.version}</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>

      <dependency>
        <groupId>org.jboss.spec</groupId>
        <artifactId>jboss-javaee-6.0</artifactId>
        <type>pom</type>
        <scope>import</scope>
      </dependency>
    </dependencies>
  </dependencyManagement>
---------

So that takes care of managing all the dependency __versions__. Now
let's declare the libraries we'll be using:

---------
  <dependencies>
  
    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-js</artifactId>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-server</artifactId>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-security-client</artifactId>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-security-server</artifactId>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-backend-server</artifactId>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-nio2-fs</artifactId>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-nio2-jgit</artifactId>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-client-api</artifactId>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-widgets-core-client</artifactId>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-widgets-commons</artifactId>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-widget-markdown</artifactId>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-workbench</artifactId>
    </dependency>

    <dependency>
      <groupId>org.jboss.errai</groupId>
      <artifactId>errai-javaee-all</artifactId>
    </dependency>

    <dependency>
      <groupId>org.jboss.spec.javax.ejb</groupId>
      <artifactId>jboss-ejb-api_3.1_spec</artifactId>
      <scope>provided</scope>
    </dependency>

    <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-log4j12</artifactId>
      <scope>provided</scope>
    </dependency>

    <!-- All of this stuff is supplied by the app server and must not be deployed with the .war file! -->
    <dependency><groupId>org.slf4j</groupId><artifactId>slf4j-api</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>log4j</groupId><artifactId>log4j</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>com.google.guava</groupId><artifactId>guava-gwt</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>hsqldb</groupId><artifactId>hsqldb</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>javax.annotation</groupId><artifactId>jsr250-api</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>javax.enterprise</groupId><artifactId>cdi-api</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>javax.inject</groupId><artifactId>javax.inject</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>javax.validation</groupId><artifactId>validation-api</artifactId><classifier>sources</classifier><scope>provided</scope></dependency>
    <dependency><groupId>javax.validation</groupId><artifactId>validation-api</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>junit</groupId><artifactId>junit</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.hibernate.common</groupId><artifactId>hibernate-commons-annotations</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.hibernate.javax.persistence</groupId><artifactId>hibernate-jpa-2.0-api</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.hibernate</groupId><artifactId>hibernate-core</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.hibernate</groupId><artifactId>hibernate-entitymanager</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.hibernate</groupId><artifactId>hibernate-validator</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.hibernate</groupId><artifactId>hibernate-validator</artifactId><classifier>sources</classifier><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.errai</groupId><artifactId>errai-cdi-jetty</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.errai</groupId><artifactId>errai-codegen-gwt</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.errai</groupId><artifactId>errai-data-binding</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.errai</groupId><artifactId>errai-javax-enterprise</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.errai</groupId><artifactId>errai-jaxrs-client</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.errai</groupId><artifactId>errai-jpa-client</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.errai</groupId><artifactId>errai-navigation</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.errai</groupId><artifactId>errai-tools</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.logging</groupId><artifactId>jboss-logging</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.resteasy</groupId><artifactId>jaxrs-api</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.spec.javax.interceptor</groupId><artifactId>jboss-interceptors-api_1.1_spec</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.spec.javax.transaction</groupId><artifactId>jboss-transaction-api_1.1_spec</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.weld.servlet</groupId><artifactId>weld-servlet-core</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.weld</groupId><artifactId>weld-api</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.weld</groupId><artifactId>weld-spi</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>xml-apis</groupId><artifactId>xml-apis</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.errai.io.netty</groupId><artifactId>netty</artifactId><scope>provided</scope></dependency>

    <!-- And finally, add this -->
    <dependency>
      <groupId>org.jboss.errai</groupId>
      <artifactId>errai-jboss-as-support</artifactId>
      <scope>compile</scope>
    </dependency>

  </dependencies>
---------

So that takes care of adding UberFire, Errai, and the Java EE 6 APIs
to the project.

Now on to the `<build>` section, where we define the behaviour of
several plugins we'll need in order to get the project built.

---------
  <build>

    <resources>
      <resource>
        <directory>src/main/java</directory>
      </resource>
      <resource>
        <directory>src/main/resources</directory>
      </resource>
    </resources>

    <plugins>
      <!-- see below in this guide -->
    </plugins>

  </build>
---------

The `<resources>` section adds `src/main/java` as a resource
directory, and reaffirms that `src/main/resources` is also a resource
directory. The purpose of adding `src/main/java` as a resource
directory is to ensure all the .java source files are included on the
build path. The GWT compiler requires this. The reason we add
`src/main/resources` redundantly is because the Maven integration in
IntelliJ IDEA does not retain this default resource directory when you
add a new one. Adding both provides maximum compatibility.

Now, how do we teach Maven to perform the extra build steps that are
unique to an UberFire-based project? That's where the plugins come in.

Note that all of the following `<plugin>` elements go inside the
`<plugins>` placeholder we defined in the previous step.

First up, we'll define some settings for `maven-compiler-plugin`:

---------
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>2.4</version>
        <configuration>
          <source>1.6</source>
          <target>1.6</target>
        </configuration>
        <dependencies>
          <dependency>
            <groupId>org.uberfire</groupId>
            <artifactId>uberfire-workbench</artifactId>
            <version>${uberfire.version}</version>
          </dependency>
        </dependencies>
      </plugin>
---------

The `source` and `target` options set the compiler for Java 1.6
compliance. This is the version of the Java language that GWT 2.5
supports.

The dependency on `uberfire-workbench` is the recommended way of
hinting Eclipse's Maven integration that this module contains Java
Annotation Processors that should be executed whenever an incremental
build is performed. More on this later (TODO: link to m2e setup).

Next up, the all-important `gwt-maven-plugin`.

---------
      <plugin>
        <groupId>org.codehaus.mojo</groupId>
        <artifactId>gwt-maven-plugin</artifactId>
        <version>${maven.gwt.plugin.version}</version>
        <configuration>

          <noServer>true</noServer>

          <!-- Change to false if using client-side Bean Validation -->
          <strict>true</strict>

          <!-- If you can't use strict mode, diagnose mysterious
               rebind errors by setting this to DEBUG -->
          <logLevel>INFO</logLevel>

          <runTarget>http://localhost:8080/${project.artifactId}/</runTarget>

          <!-- do not insert line breaks in this string; it breaks Windows compatibility -->
          <extraJvmArgs>-Xmx1g -Xms756m -XX:MaxPermSize=256m -XX:CompileThreshold=1000</extraJvmArgs>

        </configuration>
        <executions>
          <execution>
          <id>gwt-compile</id>
            <goals>
              <goal>resources</goal>
              <goal>compile</goal>
            </goals>
          </execution>
          <execution>
            <id>gwt-clean</id>
            <phase>clean</phase>
            <goals>
              <goal>clean</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
---------

This is a lot to digest. Let's take it one step at a time.

First, we configure `noServer` because we'll be doing our Dev Mode
testing against a real JBoss EAP or WildFly instance. We don't want
Dev Mode to start its embedded Jetty server.

Next, we enable GWT's `strict` mode. This causes the build to fail
with a helpful error message when you use Java APIs that aren't
available in GWT's in-browser runtime environment. Without `strict`
mode, these errors will show up later in the compile in a way that
gives you no clue what happened. Unfortunately, as the comment notes,
`strict` mode is not compatible with client-side Bean Validation, so
you will have to turn it off when and if you start using Bean
Validation in your app's client-side code. The inferior alternatve
to `strict` mode is to set Dev Mode's `logLevel` to `DEBUG` and sift
through the output for clues about non-translatable code. But we don't
have to worry about that at this point.

Moving on, we set `runTarget` to the location where your webapp will
be served by the JBoss EAP or WildFly server on your workstation.

The `extraJvmArgs` increases the memory limits for the Dev Mode JVM,
and asks its JIT compiler to be more aggressive in generating native
code. We've done some experimenting and found a compile threshold of
1000 allows Dev Mode to start up a little faster.

Next up, we configure `maven-war-plugin`, which produces the .war file
during the package phase of the build:

---------
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-war-plugin</artifactId>
        <version>${maven.war.plugin.version}</version>
        <configuration>
          <warName>${project.artifactId}</warName>

          <!-- Exclude GWT client local classes from the deployment, lest 
            classpath scanners such as Hibernate and Weld get confused
            when the webapp is bootstrapping. -->
          <packagingExcludes>**/client/**/*.class</packagingExcludes>
        </configuration>
      </plugin>
---------

The first configuration tweak changes the name of the generated .war
file to just __projectname__.war rather than the default
__projectname__-__version__.war. We find this more convenient to work
with, because the deployment URL remains stable that way. If you
prefer keeping the version number in the .war file name, feel free to
omit the `<warName>` setting.

The `<packagingExcludes>` setting is vital, though: this keeps the
client-side-only classes off the web server. Anything that scans your
webapp for annotated classes or classes of a certain type (such as
Hibernate and Weld) tends to trip over classes that refer to GWT types
that only make sense in the client environment, such as Widgets and
JavaScript Native Methods. We'll get to these topics later, but for
now, just be sure to exclude your client-only classes from the .war
file.

The `<packagingExcludes>` setting accepts a comma-separated list of
patterns, so if you need to exclude more stuff later on, you can.

Now on to the clean configuration:

---------
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-clean-plugin</artifactId>
        <version>${maven.clean.plugin.version}</version>
        <configuration>
          <filesets>
            <fileset>
              <directory>${basedir}</directory>
              <includes>
                <include>www-test/**</include>
                <include>.gwt/**</include>
                <include>.errai/**</include>
                <include>src/main/webapp/WEB-INF/deploy/**</include>
                <include>src/main/webapp/WEB-INF/lib/**</include>

                <!-- If you rename your GWT module, you MUST update this too -->
                <include>src/main/webapp/UberFireTutorial/**</include>

                <include>**/gwt-unitCache/**</include>
                <include>**/*.JUnit/**</include>
                <include>monitordb.*</include>
              </includes>
            </fileset>
          </filesets>
        </configuration>
      </plugin>
---------

So yeah, the GWT tools (compiler, Dev Mode, and the JUnit test
harness) generate a lot of junk in a lot of places. Errai also
generates junk, but it's a bit more polite and keeps it all under one
.errai directory.

The one thing to keep in mind here is the commented line: if you
rename your GWT module (we'll talk about GWT modules in the next
section) you will also have to update this line to match. If the `mvn
clean` command fails to remove your generated GWT module directory,
you will run into the dreaded 'Module __yourmodule__ may need to be
(re)compiled' error.

And now on to the resources plugin:

---------
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-resources-plugin</artifactId>
        <version>${maven.resources.plugin.version}</version>
        <executions>
          <execution>
            <id>css-resources</id>
            <phase>process-resources</phase>
            <goals>
              <goal>copy-resources</goal>
            </goals>
            <inherited>false</inherited>
            <configuration>
              <resources>
                <resource>
                  <directory>src/main/java/org/jboss/errai/cdiwb/client/css</directory>
                  <filtering>false</filtering>
                </resource>
              </resources>
              <outputDirectory>src/main/webapp/css</outputDirectory>
            </configuration>
          </execution>
          <execution>
            <id>copy-resources</id>
            <phase>prepare-package</phase>
            <goals>
              <goal>copy-resources</goal>
            </goals>
            <configuration>
              <resources>
                <resource>
                  <directory>target/generated-sources/annotations</directory>
                </resource>
              </resources>
              <outputDirectory>${basedir}/target/classes</outputDirectory>
            </configuration>
          </execution>
        </executions>
      </plugin>
---------

This configuration serves two purposes: firstly, it copies CSS files
used by your Errai UI templates to a place where they will be
accessible from the web when your .war file is deployed. Secondly, it
copies .java source files that were generated by UberFire's annotation
processors into a place where they'll be on the classpath when the GWT
compiler runs. Yes, the GWT compiler needs the .java source file for
every class you want it to compile to JavaScript.

Last but not least, the `jboss-as-maven-plugin`:

---------
      <plugin>
        <groupId>org.jboss.as.plugins</groupId>
        <artifactId>jboss-as-maven-plugin</artifactId>
        <version>${jboss-as-maven-plugin.version}</version>
        <configuration>
          <filename>${project.artifactId}.${project.packaging}</filename>
        </configuration>
      </plugin>
---------

The `jboss-as-maven-plugin` is a handy tool that lets you deploy and
undeploy your project from JBoss AS 7, EAP 6, or WildFly 8. As long as
one of those servers is running locally, you can deploy your app to it
with the command `mvn jboss-as:deploy`.

Phew! That's it for the `<plugins>` section. Just one more section to
go, and you can skip it if nobody will even use Eclipse to develop
your project.

The `<pluginManagement>` section goes inside the `<build>` section
(it's a sibling of <plugins>, not a child).

---------
    <pluginManagement>
      <plugins>
        <!--This plugin's configuration is used to store Eclipse m2e settings 
          only. It has no influence on the Maven build itself. -->
        <plugin>
          <groupId>org.eclipse.m2e</groupId>
          <artifactId>lifecycle-mapping</artifactId>
          <version>1.0.0</version>
          <configuration>
            <lifecycleMappingMetadata>
              <pluginExecutions>
                <pluginExecution>
                  <pluginExecutionFilter>
                    <groupId>org.codehaus.mojo</groupId>
                    <artifactId>gwt-maven-plugin</artifactId>
                    <versionRange>[2.4.0,)</versionRange>
                    <goals>
                      <goal>resources</goal>
                    </goals>
                  </pluginExecutionFilter>
                  <action>
                    <ignore></ignore>
                  </action>
                </pluginExecution>
              </pluginExecutions>
            </lifecycleMappingMetadata>
          </configuration>
        </plugin>
      </plugins>
    </pluginManagement>
---------

As the comment says, this is actually some Eclipse-specific
configuration that's stored in the POM. It doesn't have any effect on
the build if you're not in Eclipse.

=== Directory structure

Your UberFire project will follow the standard Maven project
layout. Here's the structure:

---------
pom.xml
src/main/java/
src/main/java/com/mycompany/uftutorial/UberFireTutorial.gwt.xml
src/main/java/com/mycompany/uftutorial/client/
src/main/java/com/mycompany/uftutorial/client/css/
src/main/java/com/mycompany/uftutorial/server/
src/main/java/com/mycompany/uftutorial/shared/
src/main/resources/
src/main/resources/ErraiApp.properties
src/main/resources/app.html.template
src/main/resources/ErraiApp.properties
src/main/resources/log4j.properties
src/main/resources/login.config
src/main/resources/META-INF/
src/main/resources/META-INF/services
src/main/resources/META-INF/services/javax.enterprise.inject.spi.Extension
src/main/resources/META-INF/services/org.uberfire.java.nio.file.spi.FileSystemProvider
src/main/resources/META-INF/services/org.uberfire.security.auth.AuthenticationSource
src/main/resources/org/uberfire/public/
src/main/resources/org/uberfire/public/css/
src/main/resources/org/uberfire/public/images/
src/main/webapp/
src/main/webapp/login.jsp
src/main/webapp/WEB-INF/
src/main/webapp/WEB-INF/beans.xml
src/main/webapp/WEB-INF/web.xml
target/
---------

TODO: explain all of the above

==== .gitignore


== Set up the web.xml

=== Errai Servlet

=== UberFire Servlet

== Set up UberFire security: users and roles

== Create an Entry Point class

== Create a Panel

== Time to see it work!

== Factor out the panel's contents

== Create a second panel

== Link the two panels

== Add a menu bar

== Add a toolbar

== Define a perspective
