= Getting Acquainted With UberFire
Jonathan Fuerth <jfuerth@redhat.com>
:toc:
:source-highlighter: highlightjs
:stylesheet: asciidoctor.css

This guide will walk you through the process of setting up a new
UberFire application. Starting from an empty directory, you will
create a Maven `pom.xml` file to describe your project and its
dependencies, build up a simple application with client-side and
server-side behaviour, and learn how everything works along the way.

If you've never seen a full-blown working UberFire app before, why not
check out our Jump Start Guide first, which helps you get UberFire's
pre-made showcase application up and running on your system? This
guide will be here waiting for you when you're ready to come back and
build something yourself.

Otherwise, you're already familiar with UberFire's capabilities. So
let's get started!

== Prerequisites

This guide assumes you have the following software set up and working
on your computer:

* http://www.oracle.com/technetwork/java/javase/downloads/index.html[A
  Java Development Kit (JDK) version 6 or newer]
* http://maven.apache.org/download.cgi[Maven 3.x]
* http://www.eclipse.org/downloads/packages/eclipse-ide-java-ee-developers/keplersr1[Eclipse IDE for Java EE Developers]
  Kepler SR1 or newer, or whatever Java IDE you like better (NetBeans,
  IntelliJ IDEA)

== Layout of a Typical UberFire Project

Your UberFire project will follow the standard Maven project
layout. Most open source Java projects follow this layout these days,
so this should look familiar. Here's a rundown of the specific files
and directories you'll find in every UberFire project. Don't get hung
up on the details yet. We'll get to each of these in turn.

pom.xml::
 Maven build configuration. Tells Maven and Java IDEs how to build
 your project.
src/main/java/::
 Java sources for both the server-side and client-side go here,
 organized into subdirectories by package, just like all Java
 projects require.
src/main/java/__com/mycompany/uftutorial__/UberFireTutorial.gwt.xml::
 GWT module declaration. Specifies GWT dependencies, which packages
 contain code destined for the client side, and (optionally) more.
src/main/java/__com/mycompany/uftutorial__/client/::
 Java package containing code that will be compiled to JavaScript (as
 configured in the `UberFireTutorial.gwt.xml` module descriptor) but
 not deployed in the WAR file (as configured in the `pom.xml`).
src/main/java/__com/mycompany/uftutorial__/client/css/::
 Stylesheets referred to by Errai UI's HTML templates. Will be copied
 into the webapp during the build.
src/main/java/__com/mycompany/uftutorial__/server/::
 Java package for code that will be deployed to the server but not
 compiled to JavaScript.
src/main/java/__com/mycompany/uftutorial__/shared/::
 Java package for code that will be deployed to the server _and_
 compiled to JavaScript for the client. Typically business model
 classes and event classes go in the shared package.
src/main/resources/::
 Normal Maven project location for resources that should be on the
 classpath. In GWT projects (which means UberFire projects too),
 `src/main/java` and `src/main/resources` are both defined as resource
 paths, so it's up to you whether you put resources here or under
 `src/main/java`.
src/main/resources/app.html.template::
 This page is a FreeMarker template that contains the `<script>` tag
 that loads your GWT application code. It's translated to HTML on
 demand by `UberFireServlet`, and its as-served static contents are
 what your users will see while the JavaScript code that makes up your
 real application is downloading.

 TODO: Why FreeMarker? Why not an Errai UI Template, a static HTML
 file, or even a JSP?
src/main/resources/ErraiApp.properties::
 The Errai framework uses this file as a marker for classpath
 locations that should be scanned for Errai-annotated classes.  It's
 usually an empty file, but there are a number of
 https://docs.jboss.org/author/display/ERRAI/ErraiApp.properties[Errai
 framework settings] that can be placed here if necessary.
src/main/resources/log4j.properties::
 Standard log4j configuration file. You can use any logging framework
 with UberFire, but in this tutorial we're using log4j.
src/main/resources/login.config::
 A JAAS configuration file that specifies which login module the
 application is using.
src/main/resources/users.properties::
 List of application users and their roles. This is processed by
 UberFire's PropertyUserSource, so if you are using a different source
 of user and role information, your app won't need one of these.
src/main/resources/url_filter.yaml::
 List of URL patterns that are only accessible to authenticated users
 who belong to certain roles. Also lists public resources that are
 always served to any user. Processed by UberFire's
 URLResourceManager, which is used by UberFireSecurityFilter to
 control access to protected resources.

 TODO: Why YAML? Why not web.xml security constraints?
src/main/resources/META-INF/services/::
 Standard directory where Java extensions are configured.
src/main/resources/META-INF/services/javax.enterprise.inject.spi.Extension::
 Contains a list of CDI Portable Extensions provided by the UberFire
 framework. Affects the discovery and behaviour of server-side CDI
 beans.

 TODO: these should be declared in UberFire jars, not by the apps themselves.
src/main/resources/META-INF/services/org.uberfire.java.nio.file.spi.FileSystemProvider::
 Contains the list of UberFire virtual filesystem (VFS) providers used in
 the application, one per line. Each entry is the fully-qualified name
 of a Java class that implements UberFire's `FileSystemProvider`
 interface. The first VFS provider listed is the default.
src/main/resources/META-INF/services/org.uberfire.security.auth.AuthenticationSource::
 Contains the list of classes UberFire can use to authenticate login requests.
 Each line is the fully-qualified name of a Java class that implements
 UberFire's `AuthenticationSource` interface.
src/main/resources/org/uberfire/public/::
 All the files under this resource folder will be copied into a
 publicly accessible location within the web application. The default
 `app.html.template` file references images and CSS stored here.

 TODO: find out what causes these to be copied into the webapp!
src/main/webapp/::
 This is the standard root directory for resources that will be
 bundled in the `.war` file in a Maven-built web app project.
src/main/webapp/login.html::
 UberFire apps typically have a dedicated login page 

 TODO: why couldn't the login be served by UberFireServlet instead, in
 the same way the host page is served?

src/main/webapp/WEB-INF/::
 This is the standard directory where Java EE deployment descriptors,
 compiled Java classes, and third-party libraries go. You can also put
 your application's own non-public files under this directory. Files
 under this directory can be read by server-side code at runtime, but
 cannot be accessed by direct HTTP requests.
src/main/webapp/WEB-INF/beans.xml::
 This file declares that the web application is CDI-enabled. In
 UberFire applications, `beans.xml` normally defines some CDI
 interceptors that help enforce security rules.
src/main/webapp/WEB-INF/web.xml::
 The standard Java Servlets deployment descriptor. Defines the
 UberFire servlet, the UberFire security filter, and the Errai Servlet
 in addition to any servlets, security rules, and configuration
 required by your application's own code.

 TODO: we can eliminate the need for this file by annotating
 UberFireServlet and UberFireSecurityFilter appropriately.
target/::
 Maven writes its output here. This directory and all its contents are
 completely removed whenever you execute `mvn clean`.

== Create the Maven POM

The first thing you'll need is a Maven `pom.xml` file that describes
all the dependencies and special build steps of your project. Start
with this:

[source,xml]
---------
<?xml version="1.0" encoding="UTF-8"?>
<project
  xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
  http://maven.apache.org/xsd/maven-4.0.0.xsd">

  <modelVersion>4.0.0</modelVersion>

  <name>UberFire Tutorial</name>
  <groupId>com.mycompany.sandbox</groupId>
  <artifactId>uberfire-tutorial-workbench</artifactId>
  <version>1.0.0-SNAPSHOT</version>
  <packaging>war</packaging>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.war.plugin.version>2.1.1</maven.war.plugin.version>
    <maven.clean.plugin.version>2.4.1</maven.clean.plugin.version>
    <maven.deploy.plugin.version>2.7</maven.deploy.plugin.version>
    <maven.resources.plugin.version>2.6</maven.resources.plugin.version>
    <maven.gwt.plugin.version>2.5.1</maven.gwt.plugin.version>
    <jboss-as-maven-plugin.version>7.4.Final</jboss-as-maven-plugin.version>
    <uberfire.version>0.4.0-SNAPSHOT</uberfire.version>
    <errai.version>2.4.3-SNAPSHOT</errai.version>
  </properties>

</project>
---------

Now, underneath the properties section, we'll import four Maven __BOM__
files. BOM (short for Bill Of Materials) is a Maven pattern where
frameworks publish a comprehensive set of dependency versions that
are known to work well with the framework. We'll import BOMs for
UberFire, Errai, and the Java EE 6 APIs.

Note that importing a BOM doesn't add any actual dependencies to your
project; it simply manages the versions of the direct and transitive
dependencies you do add in the `<dependencies>` section further down.

This section can be placed right below the properties section from the
previous snippet:

[source,xml]
---------
  <dependencyManagement>
    <dependencies>

      <dependency>
        <groupId>org.jboss.errai.bom</groupId>
        <artifactId>errai-version-master</artifactId>
        <version>${errai.version}</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>

      <dependency>
        <groupId>org.jboss.errai</groupId>
        <artifactId>errai-parent</artifactId>
        <version>${errai.version}</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>

      <dependency>
        <groupId>org.uberfire</groupId>
        <artifactId>uberfire</artifactId>
        <version>${uberfire.version}</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>

      <dependency>
        <groupId>org.jboss.spec</groupId>
        <artifactId>jboss-javaee-6.0</artifactId>
        <type>pom</type>
        <scope>import</scope>
      </dependency>
    </dependencies>
  </dependencyManagement>
---------

So that takes care of managing all the dependency __versions__. Now
let's declare the libraries we'll be using:

[source,xml]
---------
  <dependencies>
  
    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-js</artifactId>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-server</artifactId>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-security-client</artifactId>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-security-server</artifactId>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-backend-server</artifactId>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-nio2-fs</artifactId>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-nio2-jgit</artifactId>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-client-api</artifactId>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-widgets-core-client</artifactId>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-widgets-commons</artifactId>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-widget-markdown</artifactId>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-workbench</artifactId>
    </dependency>

    <dependency>
      <groupId>org.jboss.errai</groupId>
      <artifactId>errai-javaee-all</artifactId>
    </dependency>

    <dependency>
      <groupId>org.jboss.spec.javax.ejb</groupId>
      <artifactId>jboss-ejb-api_3.1_spec</artifactId>
      <scope>provided</scope>
    </dependency>

    <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-log4j12</artifactId>
      <scope>provided</scope>
    </dependency>

    <!-- All of this stuff is supplied by the app server and must not be deployed with the .war file! -->
    <dependency><groupId>org.slf4j</groupId><artifactId>slf4j-api</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>log4j</groupId><artifactId>log4j</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>com.google.guava</groupId><artifactId>guava-gwt</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>hsqldb</groupId><artifactId>hsqldb</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>javax.annotation</groupId><artifactId>jsr250-api</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>javax.enterprise</groupId><artifactId>cdi-api</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>javax.inject</groupId><artifactId>javax.inject</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>javax.validation</groupId><artifactId>validation-api</artifactId><classifier>sources</classifier><scope>provided</scope></dependency>
    <dependency><groupId>javax.validation</groupId><artifactId>validation-api</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>junit</groupId><artifactId>junit</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.hibernate.common</groupId><artifactId>hibernate-commons-annotations</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.hibernate.javax.persistence</groupId><artifactId>hibernate-jpa-2.0-api</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.hibernate</groupId><artifactId>hibernate-core</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.hibernate</groupId><artifactId>hibernate-entitymanager</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.hibernate</groupId><artifactId>hibernate-validator</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.hibernate</groupId><artifactId>hibernate-validator</artifactId><classifier>sources</classifier><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.errai</groupId><artifactId>errai-cdi-jetty</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.errai</groupId><artifactId>errai-codegen-gwt</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.errai</groupId><artifactId>errai-data-binding</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.errai</groupId><artifactId>errai-javax-enterprise</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.errai</groupId><artifactId>errai-jaxrs-client</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.errai</groupId><artifactId>errai-jpa-client</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.errai</groupId><artifactId>errai-navigation</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.errai</groupId><artifactId>errai-tools</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.logging</groupId><artifactId>jboss-logging</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.resteasy</groupId><artifactId>jaxrs-api</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.spec.javax.interceptor</groupId><artifactId>jboss-interceptors-api_1.1_spec</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.spec.javax.transaction</groupId><artifactId>jboss-transaction-api_1.1_spec</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.weld.servlet</groupId><artifactId>weld-servlet-core</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.weld</groupId><artifactId>weld-api</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.weld</groupId><artifactId>weld-spi</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>xml-apis</groupId><artifactId>xml-apis</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.errai.io.netty</groupId><artifactId>netty</artifactId><scope>provided</scope></dependency>

    <!-- And finally, add this -->
    <dependency>
      <groupId>org.jboss.errai</groupId>
      <artifactId>errai-jboss-as-support</artifactId>
      <scope>compile</scope>
    </dependency>

  </dependencies>
---------

So that takes care of adding UberFire, Errai, and the Java EE 6 APIs
to the project.

Now on to the `<build>` section, where we define the behaviour of
several plugins we'll need in order to get the project built.

[source,xml]
---------
  <build>

    <resources>
      <resource>
        <directory>src/main/java</directory>
      </resource>
      <resource>
        <directory>src/main/resources</directory>
      </resource>
    </resources>

    <plugins>
      <!-- see below in this guide -->
    </plugins>

  </build>
---------

The `<resources>` section adds `src/main/java` as a resource
directory, and reaffirms that `src/main/resources` is also a resource
directory. The purpose of adding `src/main/java` as a resource
directory is to ensure all the .java source files are included on the
build path. The GWT compiler requires this. The reason we add
`src/main/resources` redundantly is because the Maven integration in
IntelliJ IDEA does not retain this default resource directory when you
add a new one. Adding both provides maximum compatibility.

Now, how do we teach Maven to perform the extra build steps that are
unique to an UberFire-based project? That's where the plugins come in.

Note that all of the following `<plugin>` elements go inside the
`<plugins>` placeholder we defined in the previous step.

First up, we'll define some settings for `maven-compiler-plugin`:

[source,xml]
---------
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>2.4</version>
        <configuration>
          <source>1.6</source>
          <target>1.6</target>
        </configuration>
        <dependencies>
          <dependency>
            <groupId>org.uberfire</groupId>
            <artifactId>uberfire-workbench</artifactId>
            <version>${uberfire.version}</version>
          </dependency>
        </dependencies>
      </plugin>
---------

The `source` and `target` options set the compiler for Java 1.6
compliance. This is the version of the Java language that GWT 2.5
supports.

The dependency on `uberfire-workbench` is the recommended way of
hinting Eclipse's Maven integration that this module contains Java
Annotation Processors that should be executed whenever an incremental
build is performed. More on this later (TODO: link to m2e setup).

Next up, the all-important `gwt-maven-plugin`.

[source,xml]
---------
      <plugin>
        <groupId>org.codehaus.mojo</groupId>
        <artifactId>gwt-maven-plugin</artifactId>
        <version>${maven.gwt.plugin.version}</version>
        <configuration>

          <noServer>true</noServer>

          <!-- Change to false if using client-side Bean Validation -->
          <strict>true</strict>

          <!-- If you can't use strict mode, diagnose mysterious
               rebind errors by setting this to DEBUG -->
          <logLevel>INFO</logLevel>

          <runTarget>http://localhost:8080/${project.artifactId}/</runTarget>

          <!-- do not insert line breaks in this string; it breaks Windows compatibility -->
          <extraJvmArgs>-Xmx1g -Xms756m -XX:MaxPermSize=256m -XX:CompileThreshold=1000</extraJvmArgs>

        </configuration>
        <executions>
          <execution>
          <id>gwt-compile</id>
            <goals>
              <goal>resources</goal>
              <goal>compile</goal>
            </goals>
          </execution>
          <execution>
            <id>gwt-clean</id>
            <phase>clean</phase>
            <goals>
              <goal>clean</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
---------

This is a lot to digest. Let's take it one step at a time.

First, we configure `noServer` because we'll be doing our Dev Mode
testing against a real JBoss EAP or WildFly instance. We don't want
Dev Mode to start its embedded Jetty server.

Next, we enable GWT's `strict` mode. This causes the build to fail
with a helpful error message when you use Java APIs that aren't
available in GWT's in-browser runtime environment. Without `strict`
mode, these errors will show up later in the compile in a way that
gives you no clue what happened. Unfortunately, as the comment notes,
`strict` mode is not compatible with client-side Bean Validation, so
you will have to turn it off when and if you start using Bean
Validation in your app's client-side code. The inferior alternatve
to `strict` mode is to set Dev Mode's `logLevel` to `DEBUG` and sift
through the output for clues about non-translatable code. But we don't
have to worry about that at this point.

Moving on, we set `runTarget` to the location where your webapp will
be served by the JBoss EAP or WildFly server on your workstation.

The `extraJvmArgs` increases the memory limits for the Dev Mode JVM,
and asks its JIT compiler to be more aggressive in generating native
code. We've done some experimenting and found a compile threshold of
1000 allows Dev Mode to start up a little faster.

Next up, we configure `maven-war-plugin`, which produces the .war file
during the package phase of the build:

[source,xml]
---------
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-war-plugin</artifactId>
        <version>${maven.war.plugin.version}</version>
        <configuration>
          <warName>${project.artifactId}</warName>

          <!--
            List of files to leave out of the .war file:
            1. GWT client-only classes confuse Hibernate and Weld's
            classpath scanners
            2. The existence of log4j.properties interferes with JBoss
            Logging configuration
           -->
          <packagingExcludes>**/client/**/*.class,**/log4j.properties</packagingExcludes>
        </configuration>
      </plugin>
---------

The first configuration tweak changes the name of the generated .war
file to just __projectname__.war rather than the default
__projectname__-__version__.war. We find this more convenient to work
with, because the deployment URL remains stable that way. If you
prefer keeping the version number in the .war file name, feel free to
omit the `<warName>` setting.

The `<packagingExcludes>` setting is vital, though: this keeps the
client-side-only classes off the web server. Anything that scans your
webapp for annotated classes or classes of a certain type (such as
Hibernate and Weld) tends to trip over classes that refer to GWT types
that only make sense in the client environment, such as Widgets and
JavaScript Native Methods. We'll get to these topics later, but for
now, just be sure to exclude your client-only classes from the .war
file. We also omit the log4j.properties file from the .war file
because it takes over JBoss Logging configuration.

The `<packagingExcludes>` setting accepts a comma-separated list of
patterns, so if you need to exclude more stuff later on, you can.

Now on to the clean configuration:

[source,xml]
---------
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-clean-plugin</artifactId>
        <version>${maven.clean.plugin.version}</version>
        <configuration>
          <filesets>
            <fileset>
              <directory>${basedir}</directory>
              <includes>
                <include>www-test/**</include>
                <include>.gwt/**</include>
                <include>.errai/**</include>
                <include>src/main/webapp/WEB-INF/deploy/**</include>
                <include>src/main/webapp/WEB-INF/lib/**</include>

                <!-- If you rename your GWT module, you MUST update this too -->
                <include>src/main/webapp/UberFireTutorial/**</include>

                <include>**/gwt-unitCache/**</include>
                <include>**/*.JUnit/**</include>
                <include>monitordb.*</include>
              </includes>
            </fileset>
          </filesets>
        </configuration>
      </plugin>
---------

So yeah, the GWT tools (compiler, Dev Mode, and the JUnit test
harness) generate a lot of junk in a lot of places. Errai also
generates junk, but it's a bit more polite and keeps it all under one
.errai directory.

The one thing to keep in mind here is the commented line: if you
rename your GWT module (we'll talk about GWT modules in the next
section) you will also have to update this line to match. If the `mvn
clean` command fails to remove your generated GWT module directory,
you will run into the dreaded 'Module __yourmodule__ may need to be
(re)compiled' error.

And now on to the resources plugin:

[source,xml]
---------
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-resources-plugin</artifactId>
        <version>${maven.resources.plugin.version}</version>
        <executions>
          <execution>
            <id>css-resources</id>
            <phase>process-resources</phase>
            <goals>
              <goal>copy-resources</goal>
            </goals>
            <inherited>false</inherited>
            <configuration>
              <resources>
                <resource>
                  <directory>src/main/java/org/jboss/errai/cdiwb/client/css</directory>
                  <filtering>false</filtering>
                </resource>
              </resources>
              <outputDirectory>src/main/webapp/css</outputDirectory>
            </configuration>
          </execution>
          <execution>
            <id>copy-resources</id>
            <phase>prepare-package</phase>
            <goals>
              <goal>copy-resources</goal>
            </goals>
            <configuration>
              <resources>
                <resource>
                  <directory>target/generated-sources/annotations</directory>
                </resource>
              </resources>
              <outputDirectory>${basedir}/target/classes</outputDirectory>
            </configuration>
          </execution>
        </executions>
      </plugin>
---------

This configuration serves two purposes: firstly, it copies CSS files
used by your Errai UI templates to a place where they will be
accessible from the web when your .war file is deployed. Secondly, it
copies .java source files that were generated by UberFire's annotation
processors into a place where they'll be on the classpath when the GWT
compiler runs. Yes, the GWT compiler needs the .java source file for
every class you want it to compile to JavaScript.

Last but not least, the `jboss-as-maven-plugin`:

[source,xml]
---------
      <plugin>
        <groupId>org.jboss.as.plugins</groupId>
        <artifactId>jboss-as-maven-plugin</artifactId>
        <version>${jboss-as-maven-plugin.version}</version>
        <configuration>
          <filename>${project.artifactId}.${project.packaging}</filename>
        </configuration>
      </plugin>
---------

The `jboss-as-maven-plugin` is a handy tool that lets you deploy and
undeploy your project from JBoss AS 7, EAP 6, or WildFly 8. As long as
one of those servers is running locally, you can deploy your app to it
with the command `mvn jboss-as:deploy`.

Phew! That's it for the `<plugins>` section. Just one more section to
go, and you can skip it if nobody will even use Eclipse to develop
your project.

The `<pluginManagement>` section goes inside the `<build>` section
(it's a sibling of <plugins>, not a child).

[source,xml]
---------
    <pluginManagement>
      <plugins>
        <!--This plugin's configuration is used to store Eclipse m2e settings 
          only. It has no influence on the Maven build itself. -->
        <plugin>
          <groupId>org.eclipse.m2e</groupId>
          <artifactId>lifecycle-mapping</artifactId>
          <version>1.0.0</version>
          <configuration>
            <lifecycleMappingMetadata>
              <pluginExecutions>
                <pluginExecution>
                  <pluginExecutionFilter>
                    <groupId>org.codehaus.mojo</groupId>
                    <artifactId>gwt-maven-plugin</artifactId>
                    <versionRange>[2.4.0,)</versionRange>
                    <goals>
                      <goal>resources</goal>
                    </goals>
                  </pluginExecutionFilter>
                  <action>
                    <ignore></ignore>
                  </action>
                </pluginExecution>
              </pluginExecutions>
            </lifecycleMappingMetadata>
          </configuration>
        </plugin>
      </plugins>
    </pluginManagement>
---------

As the comment says, this is actually some Eclipse-specific
configuration that's stored in the POM. It doesn't have any effect on
the build if you're not in Eclipse.

== Set up a .gitignore (or similar for your VCS)

It's important to avoid tracking generated files in source
control. When you accidentally check in a generated file, it will lead
to bad things in the future: merge conflicts, confusion, and coworkers
hitting you on the head with rubber chickens.

Here's the set of files you want your version control system to
ignore. This can be used as-is in a `.gitignore` file, but it should
be easy to adapt to the VCS you're using:

---------
.classpath
.project/
.settings/
.factorypath
target/
.errai/
src/main/webapp/UberFireTutorial/
src/main/webapp/WEB-INF/classes/
src/main/webapp/WEB-INF/deploy/
src/main/gwt-unitCache/
war/
gwt-unitCache/
.apt_generated/
---------

== Set up the web.xml

The `web.xml` file is the main and most fundamental configuration file
for your web application. In Java EE talk, it's your ``deployment
descriptor.''

Here's what you need in a typical UberFire `web.xml`. Create a file
`src/main/webapp/WEB-INF/web.xml` and fill it with the following:

[source,xml]
---------
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://java.sun.com/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
          http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
         version="3.0">

  <filter>
    <filter-name>UberFire Security Filter</filter-name>
    <filter-class>
      org.uberfire.security.server.UberFireSecurityFilter
    </filter-class>
    <init-param>
      <param-name>org.uberfire.cookie.id</param-name>
      <param-value>errai-cdi-workbench-cookie</param-value>
    </init-param>
  </filter>

  <filter-mapping>
    <filter-name>UberFire Security Filter</filter-name>
    <url-pattern>/*</url-pattern>
  </filter-mapping>

  <servlet>
    <servlet-name>UberFireServlet</servlet-name>
    <servlet-class>org.uberfire.server.UberfireServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
  </servlet>

  <servlet-mapping>
    <servlet-name>UberFireServlet</servlet-name>
    <url-pattern>/UberFireTutorial/UberFire.html</url-pattern>
  </servlet-mapping>

  <servlet>
    <servlet-name>ErraiServlet</servlet-name>
    <servlet-class>org.jboss.errai.bus.server.servlet.DefaultBlockingServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
  </servlet>

  <servlet-mapping>
    <servlet-name>ErraiServlet</servlet-name>
    <url-pattern>*.erraiBus</url-pattern>
  </servlet-mapping>

</web-app>
---------

=== UberFire security filter

The UberFireSecurityFilter is mapped to `/*` and so it is consulted
for every request to a servlet or static resource in your web
application. This filter makes an allow/deny decision for each of
these requests.

How do you control the behaviour of this filter? It depends.  The
filter relies on a series of pluggable mechanisms to make its
decisions about how users can identify themselves, which
username+password combinations are valid, and which URLs anonymous and
authenticated users are allowed to access.

For this demo, we will control access using the default settings, which are:

* Authentication Manager (controls login and logout): `HttpAuthenticationManager`
** Authentication Schemes (extract provided credentials from HTTP requests):
*** HTTP BASIC (`HttpBasicAuthenticationScheme`)
*** JAAS standard form authentication, i.e. POST to j_security_check (`FormAuthenticationScheme`)
*** UberFire ``Remember Me'' cookies (`RememberMeCookieAuthScheme`)
** Authentication Providers: `DefaultAuthenticationProvider` and `RememberMeCookieAuthProvider`
** Authenticated Storage Providers: `HttpSessionStorage` and `CookieStorage`
** Resource Manager: `URLResourceManager`
** Role Providers: `PropertyUserSource` (read from the `users.properties` file)
** Subject Properties Provider: Not used
* Authorization Manager: `DefaultAuthorizationManager`
** Voting Strategy: `ConsensusBasedVoter`
** Role Decision Manager: DefaultRoleDecisionManager
** Resource Manager: `URLResourceManager`
** Resource Decision Managers: `URLAccessDecisionManager`

TODO: define the terms used above: authentication, HTTP BASIC, JAAS,
Authenticated Storage, Resource, Role, Subject, Subject Properties,
Authorization, Decision Manager, Voting Strategy, and Consensus-based voting.

=== UberFire servlet

The UberFireServlet is responsible for serving the application's GWT
host page, which is mapped to the URL
`/UberFireTutorial/UberFire.html`. Users are directed to this page
after a successful login.

The servlet works by processing the FreeMarker template
`app.html.template` and serving the result to the client.

=== Errai servlet

The ErraiServlet is responsible for the communication bus that allows
two-way-push communication between the client and the server.

== Set up UberFire security

=== Define users and roles

Our application uses the `PropertyUserSource` for its list of users,
passwords, and role memberships. This user source is mostly applicable
to development and demo environments. It gets its user, password, and
role membership information from the file
`src/main/resources/users.properties`.

You can define a default set of users by filling in
`src/main/resources/users.properties` with something like this:

---------
admin=admin,ADMIN,USERS,DIRECTOR,MANAGER
director=director,USERS,DIRECTOR,MANAGER
user=user,USERS
guest=guest
---------

The format of each line is `username=password[,ROLE1[,ROLE2[,...]]]`.
The brackets indicate optional parts.

=== Create a login.html

Our application allows a variety of authentication mechanisms,
including JAAS form authentication. This mechanism is specified in the
Java Servlets specification: the web browser makes a POST request to
the URL `j_security_check` and includes form parameters `j_username`
and `j_password`. We'll create a `login.html` page that includes a form
which submits the correct information to the correct URL.

Place the following file in `src/main/webapp/login.html`:

[source,html]
---------
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>UberFire Tutorial</title>

  <style type="text/css">
    * {
      font-family: Helvetica, Arial, sans-serif;
    }

    body {
      margin: 0;
      padding: 0;
      color: #fff;
      background:
      url('UberFireTutorial/images/bg-login.png')
      repeat #1b1b1b;
      font-size: 14px;
      text-shadow: #050505 0 -1px 0;
      font-weight: bold;
    }

    li {
      list-style: none;
    }

    #dummy {
      position: absolute;
      top: 0;
      left: 0;
      border-bottom: solid 3px #777973;
      height: 250px;
      width: 100%;
      background:
      url('UberFireTutorial/images/bg-login-top.png')
      repeat #fff;
      z-index: 1;
    }

    #dummy2 {
      position: absolute;
      top: 0;
      left: 0;
      border-bottom: solid 2px #545551;
      height: 252px;
      width: 100%;
      background: transparent;
      z-index: 2;
    }

    #login-wrapper {
      margin: 0 0 0 -160px;
      width: 320px;
      text-align: center;
      z-index: 99;
      position: absolute;
      top: 0;
      left: 50%;
    }

    #login-top {
      height: 120px;
      width: 401px;
      padding-top: 20px;
      text-align: center;
    }

    #login-content {
      margin-top: 120px;
    }

    label {
      width: 70px;
      float: left;
      padding: 8px;
      line-height: 14px;
      margin-top: -4px;
    }

    input.text-input {
      width: 200px;
      float: right;
      -moz-border-radius: 4px;
      -webkit-border-radius: 4px;
      border-radius: 4px;
      background: #fff;
      border: solid 1px transparent;
      color: #555;
      padding: 8px;
      font-size: 13px;
    }

    input.button {
      float: right;
      padding: 6px 10px;
      color: #fff;
      font-size: 14px;
      background: -webkit-gradient(linear, 0% 0%, 0% 100%, from(#a4d04a), to(#459300));
      text-shadow: #050505 0 -1px 0;
      background-color: #459300;
      -moz-border-radius: 4px;
      -webkit-border-radius: 4px;
      border-radius: 4px;
      border: solid 1px transparent;
      font-weight: bold;
      cursor: pointer;
      letter-spacing: 1px;
    }

    input.button:hover {
      background: -webkit-gradient(linear, 0% 0%, 0% 100%, from(#a4d04a), to(#a4d04a), color-stop(80%, #76b226));
      text-shadow: #050505 0 -1px 2px;
      background-color: #a4d04a;
      color: #fff;
    }

    div.error {
      padding: 8px;
      background: rgba(52, 4, 0, 0.4);
      -moz-border-radius: 8px;
      -webkit-border-radius: 8px;
      border-radius: 8px;
      border: solid 1px transparent;
      margin: 6px 0;
    }
  </style>
</head>

<body id="login">

<div id="login-wrapper" class="png_bg">
  <div id="login-top">
    <img src="UberFireTutorial/images/uf_logo.png" alt="UberFire Logo" title="Powered By UberFire"/>
  </div>

  <div id="login-content">
    <form action="j_security_check" method="post">
      <p>
        <label>Username</label>
        <input value="" name="j_username" class="text-input" type="text"/>
        <br style="clear: both;"/>
      </p>

      <p>
        <label>Password</label>
        <input name="j_password" class="text-input" type="password"/>
        <br style="clear: both;"/>
      </p>

      <p>
        <input class="button" type="submit" value="Sign In"/>
      </p>
    </form>
  </div>
</div>
<div id="dummy"></div>
<div id="dummy2"></div>
</body>
</html>
---------

The important part of this file is the form that posts `j_username`
and `j_password` to the `j_security_check` URL. This will be
recognized by UberFireSecurityFilter as a login attempt.

== Create a client-side entry point class

Okay, enough mucking around with directory structure and configuration
files! We went through all of that because it's important to
understand everything you put into your web application, and doing
something is the best way to learn it. In the future, you'll probably
want to just start with a copy of a working demo app and delete the
parts you don't need.

An _entry point_ is a place where a program starts its execution. In
JavaSE programs, the entry point is the famous `public static void
main(String[] args)` method. In a Java EE environment, you typically
have many entry points: every Servlet and JAX-RS resource method is an
entry point into the application.

In an UberFire application, there are typically _client side_
components (the parts that are translated to JavaScript and execute in
the browser) and _server side_ components (the parts that are compiled
to class files and deplotyed in the war file.)

Any class in a client-only package of your application can be a
client-side entry point into your application. To designate a class as
an entry point, annotate it with `@EntryPoint`. Put the following in
`src/main/java/com/mycompany/uftutorial/client/ClientEntryPoint.java`:

[source,java]
---------
@EntryPoint
public class ClientEntryPoint {
  private void start(@Observes final ApplicationReadyEvent event) {
  }
}
---------

The `@EntryPoint` annotation tells the framework that the class is a
CDI Bean that should be instantiated when the page is loaded into the
browser. You can name an entry point class anything you like. You can
create as many `@EntryPoint` classes as you want, but you can't
specify what order they will be instantiated in. It's unusual to have
more than one.

The `start()` method is a CDI observer method. The UberFire Workbench
framework fires an `ApplicationReadyEvent` when the framework has
finished initializing.

NOTE: Since the entry point class is a CDI bean, it's tempting to use
the CDI `@PostConstruct` annotation on the method that runs your
initialization code. However, this does not work in practice because
it's usually invoked too early: before many parts of the framework
(including the Errai communication bus) have had a chance to
initialize. Stick with observing `ApplicationReadyEvent` and you'll be
fine.

Right now, our entry point method is empty! What kind of stuff would
you normally put in there for bootstrapping an UberFire app? Let's
create a panel and come back to that question.

== Create a panel

UberFire interfaces are made up of a few fundamental building blocks:
Widgets, Panels, Menu Bars, Tool Bars, and Perspectives. Panels
can contain Widgets and other Panels, and Perspectives give end users
the ability to rearrange Panels on the screen by dragging and dropping
them. Use of Perspectives is optional, so we'll leave them for later.

To create your first panel, create the file
`src/main/java/com/mycompany/uftutorial/client/PanelOne.java`:

[source,java]
---------
package com.mycompany.uftutorial.client;

import javax.enterprise.context.Dependent;
import javax.inject.Inject;

import org.uberfire.client.annotations.WorkbenchPartTitle;
import org.uberfire.client.annotations.WorkbenchPartView;
import org.uberfire.client.annotations.WorkbenchScreen;

import com.google.gwt.user.client.ui.IsWidget;

@Dependent
@WorkbenchScreen(identifier="PanelOne")
public class PanelOne {

  private Label label = new Label("This is panel one");

  @WorkbenchPartTitle
  public String getName() {
    return "Panel One!";
  }

  @WorkbenchPartView
  public IsWidget getView() {
    return label;
  }
}
---------

== Time to see it work!

== Factor out the panel's contents

== Create a second panel

== Link the two panels

== Add a menu bar

== Add a toolbar

== Define a perspective
